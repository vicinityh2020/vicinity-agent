# (Multi) Agent Service for integrators

VICINITY Agent serves as the interface between VICINITY GateWay and VICINITY Adapter.
Agent is the functional extension of Adapter. The role of Agent is to make the life of Adapter developers easier.

The responsibility of agent is:
* to translate between object infrastructure identifiers (**infrastructure-id**) used by Adapter
and VICINITY identifiers (**oid**).
* to automatize common tasks, like **discovery/configuration** and **opening/subscribing to event channels**
* to translate between common VICINITY consumption/eventing services (implemented in GTW API) into specific Adapter services, depending
 how they are described in Thing Descriptions
* translating Adapter requests for consumption/event services into common VICINITY services (implemented in GTW API), with proper credentials

Agent Service was adjusted to handle multiple client nodes, so it was enhanced from agent to multi-agent.
Agent is now service able to manage multiple agent configurations.
The purpose was to, again, make life of adapter developers easier. The main trigger was,
that if some service provider must run multiple client nodes (e.g. in the cloud), for
each client node, the separate software (adapter, agent, gtw), has to be deployed and runed.
If provider has to run really many client nodes, the management of deployed software
becomes critical (for each client node, there physically run three software components).
Switch to multi-agent concept enables to run only one physical deployment for as many client
nodes as needed.

See also [details of auto discovery/configuration](DISCO.md) process.

The full [Agent Service API](AGENT_API.md)

Now, in details.

# Installation guide

## Deployment and re-deployment

Agent comes with and requires the following directory structure:
```
config/
    db/
    agents/
        agent-1-config.json
        ..
        agent-x-config.json
    service-config.json
logs/
agent.jar
agent.sh
```

*config/service-config.json* contains the service configuration shared by all included agents.
*agents/* contains configuration files for agents to be managed
*logs/* contains all agent logs files
*agent.jar* is the executable
*agent.sh* is the script to run/stop the agent


**!!!VERY IMPORTANT!!!** folder **config/db** contains local agent configuration storage, with all mappings and credentials.
Once any content in this folder is manually removed or edited, local configuration may be lost and all objects in
this node may be treated as new. This leads to dropping whole configuration also in Neighbourhood manager, including
friendships and permissions.


Run the agent:
```
#!shell

./agent.sh
```

Stop the agent:
```
#!shell

./agent.sh stop
```

To redeploy the Agent, simply stop the agent, replace the **agent.jar** file and run it again.

**Agent Service runs at default endpoint**:

```
http://localhost:9997/agent
resp.
http://IP:PORT/agent
```

## Download

Agent skeleton (folder structure above) and most recent **agent-vX.Y.Z.jar** are now
**[available here](../agent-service/build)**.

When changing to new **agent-vX.Y.Z.jar**,
please, update **JAR** variable in **agent.sh** script to new JAR version.


## Configuration

The service configuration, shared by all included agents is located in *config/service-config.json* file.
Now it contails only the endpoint to GTW API.

```
config/service-config.json:
#!json
{
    "gateway-api-endpoint": "http://localhost:8181/api"
}
```

The configuration for all included agent components can be found in *config/agents/* folder. The config per each agent component looks as follows:
```
config/agents/any-agent-config.json:
#!json
{
    "credentials": {
        "agent-id": "agent id generated by Neighbourhood Manager",
        "password": "agent id generated by Neighbourhood Manager"
    },
    "adapters": [
        {
            "adapter-id": "unique id of adapter"
            "active-discovery": true/false
            "endpoint": "http://localhost:9995/adapter",
            "events": {
                "channels": [
                    {
                        "infrastructure-id": "internal identifier of object publishing the event",
                        "eid": "object event identifier",
                    }
                ],
                "subscriptions": [
                    {
                        "infrastructure-id": "internal identifier of object subscribing for the event",
                        "oid": "VICINITY object id",
                        "eid": "object event identifier",
                    }
                ]
            }

        }
    ]
}
```

Set agent credentials to **agent id** and **password** generated by Neighbourhood Manager, when VICINITY node
was created. Set the endpoint to GTW API. Add the list of Adapters to be handled by this agent.

### Configuration of adapters

One agent component may manage multiple adapters, **each adapter must provide its unique identifier**.

#### adapter-id

**adapter-id must be specific for whole agent service. Just ensure, it is unique!**
Agent service must be able to unambiguously decide, which object belongs to which adapter
and which adapter belongs to which agent.

Generate **adapter-id** as **unique hash code** and **store it in your adapter code**.
It will be required, when talking to agent, this prevents the ambiguity in
object identifiers (case, when different adapters contain objects with
identical infrastructure-id).

#### active-discovery

Discovery may be triggered by agent, but now, also by adapter proactively.
If you want your adapter to trigger the discovery, in agent config "adapters", use property
**"active-discovery": true/false**.

If set to true, agent will not try to invoke discovery, agent will wait for agent to do this.
When running node, adapter must be started as last component!

If set to false, agent will invoke discovery when started.
When running node, agent must be started as last component!

Default is : **"active-discovery": false**.

#### endpoint

**endpoint** parameter is optional.
When **endpoint** is not provided, that means, that only possible communication
is **adapter -> agent**. In this case, agent can not speak to adapter and
discovery must be invoked by adapter.

For this reason, **"active-discovery"** must be set to **true**.
If **"endpoint"** is missing and **"active-discovery"** is missing, **"active-discovery"** is set to **true** by default.


### Additional configuration

Additional configuration can be changed in **agent.sh** script. If needed, it is possible to change the port, where Agent will run,
the log folder destination and the path to agent config json file. Just edit following variables in **agent.sh** script:

```
SERVER_PORT=9997
CONFIG_FILE=config/service-config.json
AGENT_CONFIG_FOLDER=config/agents
LOGS_FOLDER=logs
```



## Agent response
The response of agent is always wrapped into following structure:

Success:
```
#!json
{
    "status": "success"
    "data": {
        untouched payload object returned by requested component
    }
}
```

Failure:
```
#!json
{
    "status": "failure"
    "reason": "the reason of failure, as much known as possible",
}
```

The only exception is the access to remote objects or receiving the events. In those cases,
the response from GTW API is forwarded as it was received without touching it.




# Data consumption services

Data consumption services allows to read/set property value or execute/read status of action on the object.

**Important!** If object needs to use consumption services on another object, the proper permissions must be set in Neighbourhood manager.
Otherwise this interaction will be rejected on level of GTW API.

## Object properties



### Consuming property of remote object (at another VICINITY node)

**Consuming of remote object property is always invoked by object behind the Adapter.** Thus, object must
have permissions to consume the remote object property and proper VICINITY credentials
of this object must be provided.

To read remote object property value, the Agent implements the endpoint:
```
GET : /remote/objects/{oid}/properties/{pid}
```

To set remote object property value, the Agent implements the endpoint:
```
PUT : /remote/objects/{oid}/properties/{pid}
```
PUT operation requires the payload with data structure specified in thing description for this property input to set the value.


If **object from this infrastructure** (for which this Agent runs) wants to get/set property of **remote object** (another VICINITY node),
in both calls, **the request header must contain key-value pairs**:
```
infrastucture-id=infrastructure-id of requesting object
adapter-id=identifier of adapter for this object
```

Agent finds the corresponding **oid** for requesting object matching **infrastructure-id** in header and translates
this request into corresponding GTW API call, setting the proper VICINITY credentials for requesting object.



### How agent processes the consumption of local object property (in this VICINITY node)

To read local object property value, the Agent calls the endpoint provided in *read_link* of object:
```
GET : read_link endpoint for object property
```

**Adapter must implement this endpoint.**


To set local object property value, the Agent calls the endpoint provided in *write_link* of object:
```
PUT : write_link endpoint for object property
```

**Adapter must implement this endpoint.**


PUT operation requires the payload with data structure specified in thing description for this property input to set the value.

When Agent receive the property consumption request, it translates this requests into corresponding Adapter endpoints and execute it.
This process is described in details in [Adapter interaction patterns](ADAPTER.md#interaction-patterns)

## Object actions

### Executing action on remote object (at another VICINITY node)

**Executing of action on remote object is always invoked by object behind the Adapter.** Thus, object must
have permissions to execute the action and proper VICINITY credentials
of this object must be provided.

To execute remote object action, Agent implements the endpoint:
```
POST: /remote/objects/{oid}/actions/{aid}
```

POST operation requires the payload with data structure specified in thing description for this action input. Action input represents the input parameters for this action.


If **object from this infrastructure** (for which this Agent runs) wants to execute of **remote object** (another VICINITY node),
**the request header must contain key-value pairs** identifying the object requesting the information:
```
infrastucture-id=infrastructure-id of requesting object
adapter-id=identifier of adapter for this object
```

Agent finds the corresponding **oid** for requesting object matching **infrastructure-id** in header and translates
this request into corresponding GTW API call, setting the proper VICINITY credentials for requesting object.

The Gateway response for this call is always the payload:

```
#!json
{
    "error": "false"
    "message": [
        {
            "startAction": "success"
        },
        {
            "taskID": "d4d0ae7d-275f-40d0-a4d9-704535166ae7"
        }
    ]
}
```

The action is now being executed on the remote object. Any further
attempt to start this action will result in tasks, that are queued, but
not executed yet, until the previous one is finished (max number of
tasks in queue as well as their expiration time is configurable on the
gateway closest to the object providing the action).

This payload is passed back to Adapter, which is responsible to pass it to object that triggered the action.
It is important to remember the *taskID* attached to action execution. It will be required, if
there is need to read the status of action execution or to cancel the running task.

### How agent processes the execution of action on target object

To execute the local object action, the Agent calls the endpoint provided in *write_link* of object action:
```
POST : write_link endpoint for object action providing the property
```

**Adapter must implement this endpoint.**


When Agent receive the action execution request, it translates this requests into corresponding Adapter endpoints and execute it.

### Updating the status of the task

The object, that is executing the task, is capable of updating its
status. Note that it does not need to know the task ID, which is used
only for gateway's internal representation and management of incomming
requests. When a request for action execution comes,
the object starts executing it. When it is done, it sends
a result back to agent, which passes it back to gateway. The gateway's internal logic protects the
object from being overwhelmed by requests by assigning a
task ID to each request, queuing them and keeping the return values of
already finished tasks.

The object updates the status of action by calling Agent endpoint:

```
PUT: /actions/{aid}
```

To identify, which object is updating status of the task, the request headers must be set:
```
infrastucture-id=infrastructure-id of requesting object
adapter-id=identifier of adapter for this object
status=identifier of status
```

**Status header** must be one of following values:
* **running** - use this status to keep the action running. For example when
you want to periodically update currently running task with preliminary
return values, or a percentage of progress or whatever, you use this one.
* **finished** - use this when action was finished with satisfactory results.
This status will cause the gateway to move on to the next task in the
queue, so expect that another action will be requested under a second
(if there are tasks in the queue).
* **failed** - use this to indicate that the action was interrupted by error.
This status will cause the gateway to move on to the next task in the
queue, so expect that another action will be requested under a second
(if there are tasks in the queue).


Request body must not be empty, it can contain the result of action exectution data, information about
progress, etc.

This request is translated to proper Gateway call with object VICINITY **oid** and credentials.

### Getting the status of the task

After object executed the action on remote object, the **taskID** is returned to it in response.
Using this **taskID** it is possible to track the status of the action exectution.
The
status you receive can be one of the following:

* **finished** - the task was finished successfully
* **failed** - the task encountered an error during execution
* **running** - the task is currently runnning
* **pending** - the task is awaiting previous task on this action to finish
* **unknown** - if you see this, file a bug report to Martin.

To get the action status, Agent implements the endpoint:

```
GET: /remote/objects/{oid}/actions/{aid}/tasks/{tid}
```

**The request header must contain key-value pairs** identifying the object requesting the information:
```
infrastucture-id=infrastructure-id of requesting object
adapter-id=identifier of adapter for this object
```

Agent finds the corresponding **oid** for requesting object matching **infrastructure-id** in header and translates
this request into corresponding GTW API call, setting the proper VICINITY credentials for requesting object.

The Gateway response for this call is always the payload:

```
#!json
{
    "error": "false"
    "message": [
        {
            "taskStatus": "success"
        },
        {
            "returnValue": "{\n\t\"value\": \"42\"\n}"
        }
    ]
}
```

The return value is the payload attached to *update action status* service by object, that updated its action status.

### Canceling a task

A task on a remote object can be cancelled, if it is either in the
'running' or 'pending' status.

To cancel the task, Agent provides the endpoint:
```
GET: /remote/objects/{oid}/actions/{aid}/task/{tid}
```

**The request header must contain key-value pairs** identifying the object requesting the information:
```
infrastucture-id=infrastructure-id of requesting object
adapter-id=identifier of adapter for this object
```

Agent finds the corresponding **oid** for requesting object matching **infrastructure-id** in header and translates
this request into corresponding GTW API call, setting the proper VICINITY credentials for requesting object.

The status of the task is then changed to **finshed** and removed from execution queue on Gateway.

### How agent processes the canceling of task on target object

To cancel the local object running action, the Agent calls the endpoint provided in *write_link* of object action:
```
DELETE : write_link endpoint for object action providing the property
```

**Adapter must implement this endpoint.**

When Agent receive the action execution request, it translates this requests into corresponding Adapter endpoints and execute it.


# Eventing

Consumption services enable to read object properties by request. The eventing mechanism enables objects to publish
the values of their properties (or whatever needs to be published) once, the conditions are met.
So other object can receive data automatically, without explicitly requesting it.

The VICINITY eventing mechanism is implemented as publish/subscribe pattern.

## Event channel management

The name of event channel for object is always specified as: **/objects/{oid}/event/{eid}**. Any object can open its channel for
concrete event and publish data into it. Once the channel is open, other objects may subscribe to this channel. Once the object is subscribed to the channel,
Adapter of this object will receive events from this channel, when they appear.

Opening the channels and subscriptions may be done statically, using Agent configuration file; or dynamically on the fly.
Events are configured per each Adapter separately (as event publisher or subscriber must always be the concrete object)

### Static channel management

Opening the channels and subscriptions may be declared in Agent configuration file, field **adapters/events**.
```
#!json
{
    ...
    "adapters": [
        {
            "adapter-id": "guess what",
            "events": {
                "channels": [
                    {
                        "infrastructure-id": "internal identifier of object publishing the event",
                        "eid": "object event identifier",
                    }
                ],
                "subscriptions": [
                    {
                        "oid": "VICINITY object id producing event",
                        "eid": "object event to listen subscribe",

                        "infrastructure-id": "internal identifier of object subscribing for the event",
                    }
                ]
            }
        }
    ]
}
```

Field **channels** contains the array of declarations, for which object and its event the channel should be open.
As the channel is to be open for local object (within this VICINITY node), the **infrastructure-id** of object behind the Adapter
is used.
The channel **/objects/{oid}/events/{eid}** is open, where **oid** is VICINITY identifier of object with **infrastructure-id**.

Field **subscriptions** contains the array of declarations, to which channels the Adapter objects will listen.
The **infrastructure-id** specifies object behind the Adapter, which is subscribed to channel, the **oid** specifies the object producing event.
The object with **infrastructure-id** is subscribed to channel **/objects/{oid}/events/{eid}**, where **oid** is VICINITY identifier of object producing event.


Using this declaration, the Agent will create and subscribe to channels when it starts.

### Dynamic channel management

In some cases, some object in Adapter needs to open or subscribe to channel on the fly (depending on its internal logic).

To **open channel**, Agent provides the service:
```
POST /events/{eid}
headers:
infrastructure-id=internal id of object publishing the event
adapter-id=adapter for this object
```

Request parameter **infrastructure-id** specifies the identifier of object, which will publish the events.
The channel is open for this object.


The body of this request must be empty.

Agent translates this request into proper GTW API call, using credentials for object with **infrastructure-id**.

Just to note, the channel of object with **infrastructure-id** may be open by another object (e.g. value added service
may open the channel for sensor). The credentials will be provided for object with **infrastructure-id**, as if object
opened the channel by itself.


To **subscribe to channel**, Agent provides the service:
```
POST /objects/{oid}/events/{eid}
headers:
infrastructure-id=internal object id
adapter-id=adapter for this object
```
The request parameter **oid** specifies the VICINITY oid of object, to which channel this subscription applies.


The request must contain the header with key **infrastructure-id**, which specifies the internal object,
that will listen to this channel.


The body of this request must be empty.

Agent translates this request into proper GTW API call, using credentials for object with **infrastructure-id**.


## Publishing the event

Object, for which the channel is opened may publish data into this channel by using Agent service:
```
PUT /events/{eid}
headers:
infrastructure-id=internal id of object publishing the event
adapter-id=adapter for this object
```

Body of this request must be JSON payload with published event data.

Agent translates this request into proper GTW API call, using credentials for object with **infrastructure-id**.


## Consuming the event

Agent automatically pass the events into Adapter, as they appear. If Adapter needs to listen to events, Adapter
must implement the service for event consumption (see [Adapter docs on event consumption](ADAPTER.md#consumption-of-events))

In current implementation, the Adapter is responsible for processing the events and passing them further to subscribed objects in Adapters.
